/*Задание 1 (тайминг 20 минут)
1. Создайте функцию delayedMessage(message, delay),
которая принимает аргументы message (строка) и delay
(число). Функция должна выводить заданное сообщение в
консоль через указанную задержку.
2. Вызовите функцию delayedMessage() три раза с разными
сообщениями и задержками. Например:
a. delayedMessage("Сообщение 1", 2000)
b. delayedMessage("Сообщение 2", 1000)
c. delayedMessage("Сообщение 3", 3000)
3. После вызова всех функций delayedMessage(), добавьте
сообщение вида "Конец программы" с помощью
console.log().
Ожидаемый результат
Сообщение 2
Сообщение 1
Сообщение 3
Конец программы
*/
function delayedMessage(message, delay) {
    setTimeout(() => {
        console.log(message);
    }, delay);
}

delayedMessage("Сообщение 1", 2000);
delayedMessage("Сообщение 2", 1000);
delayedMessage("Сообщение 3", 3000);

setTimeout(() => {
    console.log("Конец программы");
}, 4000); // Задержка должна быть больше самой большой задержки в delayedMessage()

/*Эта функция delayedMessage принимает сообщение и задержку, а затем выводит 
сообщение в консоль через указанную задержку с помощью функции setTimeout(). 
После вызова всех функций delayedMessage добавляется сообщение "Конец программы".
*/

/*РЕШЕНИЕ С СЕМИНАРА
let max = 0;

function delayedMessage(message, delay) {
setTimeout(() => {
console.log(message)
}, delay);
if (delay > max) {
max = delay;
}
}

delayedMessage("Сообщение 1", 2000);
delayedMessage("Сообщение 2", 1000);
delayedMessage("Сообщение 3", 3000);
setTimeout(() => {
console.log('Конец программы')
}, max);
*/

/*Задание 2
Напишите программу, которая загружает данные с сервера с
использованием объекта XMLHttpRequest и отображает полученную
информацию в консоли.
1. Создайте функцию loadData(url), которая принимает аргумент url
(строка) - адрес сервера для загрузки данных.
2. Внутри функции loadData() создайте объект XMLHttpRequest с
помощью new XMLHttpRequest().
3. Зарегистрируйте обработчик события onreadystatechange, который
будет вызываться при изменении состояния запроса. Проверьте,
если readyState равен 4 (успешно выполнен запрос) и status равен
200 (успешный статус ответа сервера), то выведите полученные
данные в консоль с помощью console.log(xhr.responseText).
4. Откройте запрос с помощью xhr.open("GET", url, true), где "GET" - тип
запроса, url - адрес сервера, true - асинхронный режим запроса.
5. Отправьте запрос на сервер с помощью xhr.send().
*/
function loadData(url) {
    const xhr = new XMLHttpRequest();

    xhr.onreadystatechange = function() {
        if (xhr.readyState === 4 && xhr.status === 200) {
            console.log(xhr.responseText);
        }
    };

    xhr.open("GET", url, true);
    xhr.send();
}

// Пример использования функции
loadData("https://jsonplaceholder.typicode.com/posts/1");

/* Эта функция loadData принимает URL в качестве аргумента и создает новый объект XMLHttpRequest. 
Мы затем регистрируем обработчик события onreadystatechange, который проверяет, достигло ли 
состояние запроса readyState значения 4 (успешно выполнен) и статус ответа сервера status равен 
200 (успешный статус). Если это так, мы выводим полученные данные в консоль с помощью 
console.log(xhr.responseText). Затем мы открываем запрос с методом open, указывая тип запроса (GET), 
URL и асинхронный режим (true), и отправляем запрос на сервер с помощью метода send().*/

/*Задание 2 на семинаре
У вас есть список задач, которые необходимо выполнить в определенном порядке. 
Каждая задача должна быть выполнена через определенный промежуток времени, заданный в 
миллисекундах. Вам необходимо написать функцию, которая принимает список задач и интервал 
времени, а затем выполняет каждую задачу через определенный промежуток времени.

const tasks = [
{ name: 'task 1', time: 1000 },
{ name: 'task 2', time: 2000 },
{ name: 'task 3', time: 3000 },
{ name: 'task 4', time: 4000 },
{ name: 'task 5', time: 5000 }
];
*/

/*Можно использовать рекурсивную функцию, которая будет выполнять каждую задачу с определенной 
задержкой времени, а затем вызывать себя снова для выполнения следующей задачи.*/

function executeTasks(tasks) {
    if (tasks.length === 0) {
        console.log("Все задачи выполнены");
        return;
    }

    const task = tasks.shift();
    console.log(`Выполняется задача "${task.name}"`);
    setTimeout(() => {
        console.log(`Задача "${task.name}" выполнена`);
        executeTasks(tasks);
    }, task.time);
}

const tasks = [
    { name: 'task 1', time: 1000 },
    { name: 'task 2', time: 2000 },
    { name: 'task 3', time: 3000 },
    { name: 'task 4', time: 4000 },
    { name: 'task 5', time: 5000 }
];

executeTasks(tasks);

/* Эта функция executeTasks принимает список задач tasks. Она извлекает первую задачу из списка, 
выполняет ее с помощью setTimeout, а затем вызывает саму себя для выполнения оставшихся задач. 
Функция продолжает вызывать себя рекурсивно, пока в списке задач есть элементы. Когда все задачи 
выполнены, выводится сообщение "Все задачи выполнены".*/

/*РЕШЕНИЕ С СЕМИНАРА
const tasks = [
{ name: 'task 1', time: 1000 },
{ name: 'task 2', time: 2000 },
{ name: 'task 3', time: 3000 },
{ name: 'task 4', time: 4000 },
{ name: 'task 5', time: 5000 }
];

function executeTasks(tasks) {
tasks.forEach((task, index) => {
setTimeout(() => {
console.log(task.name);
}, task.time);
});
}

executeTasks(tasks);
*/

/* Задание 3 (тайминг 35 минут)
Напишите функцию getData, которая делает асинхронный запрос к
API и возвращает данные в виде объекта.
Внутри функции происходит асинхронный запрос к API с помощью
функции fetch. Затем, с использованием оператора await, ожидается
ответ от сервера и его парсинг в формате JSON с помощью метода
response.json(). Полученные данные возвращаются из функции.
Дополнение
В случае возникновения ошибки при выполнении асинхронных
операций, используется конструкция try/catch для обработки и
отображения ошибки.
В функции main вызывается функция getData с использованием
await, чтобы получить данные асинхронно. Полученные данные
выводятся в консоль. Если происходит ошибка, она ловится и
выводится сообщение об ошибке. Функция main также объявлена как
асинхронная с использованием ключевого слова async. В конце
вызывается функция main для запуска процесса получения данных.*/

async function getData() {
    try {
        const response = await fetch('https://api.example.com/data');
        if (!response.ok) {
            throw new Error('Ошибка HTTP: ' + response.status);
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Произошла ошибка:', error);
        throw error;
    }
}

async function main() {
    try {
        const data = await getData();
        console.log('Полученные данные:', data);
    } catch (error) {
        console.error('Произошла ошибка:', error);
    }
}

main();

/* В этом примере функция getData выполняет асинхронный запрос к API с использованием fetch. 
Затем с помощью оператора await она ожидает ответ от сервера и парсит его в формате JSON с 
помощью метода response.json(). Полученные данные возвращаются из функции. В случае возникновения 
ошибки при выполнении асинхронных операций, используется конструкция try/catch для обработки и 
отображения ошибки.

Функция main вызывает функцию getData с использованием await, чтобы получить данные асинхронно. 
Полученные данные выводятся в консоль. Если происходит ошибка, она ловится и выводится сообщение 
об ошибке. Функция main также объявлена как асинхронная с использованием ключевого слова async. 
В конце вызывается функция main для запуска процесса получения данных.*/

/* Задание с семинара
https://developer.mozilla.org/ru/docs/Web/API/Fetch_API/Using_Fetch

fetch('http://example.com/movies.json')
.then((response) => {
return response.json();
})
.then((data) => {
console.log(data);
});

Напишите программу, которая загружает данные с сервера с использованием функции fetch. 
Ваша задача — использовать предложенный шаблон запроса для получения данных и их обработки.

Создайте функцию, которая отправляет запрос к серверу, используя fetch. Адрес сервера для 
запроса: https://api.randomdatatools.ru/?count=5 .
В функции реализуйте обработку промиса, возвращаемого fetch. Используйте метод .then() для 
обработки ответа сервера.
Проверьте свойство response.ok.
Добавьте обработку ошибок с помощью метода .catch(). Выведите сообщение об ошибке в консоль, 
если в процессе выполнения запроса или обработки данных возникли проблемы.
*/

function fetchData() {
    fetch('https://api.randomdatatools.ru/?count=5')
        .then(response => {
            if (!response.ok) {
                throw new Error('Ошибка HTTP: ' + response.status);
            }
            return response.json();
        })
        .then(data => {
            console.log('Полученные данные:', data);
        })
        .catch(error => {
            console.error('Произошла ошибка:', error);
        });
}

fetchData();

/* Эта функция fetchData отправляет запрос к указанному серверу с помощью функции fetch. 
Затем она использует метод .then() для обработки ответа сервера. Проверяется свойство response.ok. 
Если ответ не содержит ошибок, данные парсятся в формате JSON и выводятся в консоль. В случае 
возникновения ошибки при выполнении запроса или обработки данных, используется метод .catch(), 
который выводит сообщение об ошибке в консоль. 
*/

/* РЕШЕНИЕ С СЕМИНАРА
function getDataFromServer(url) {
fetch(url)
.then((response) => {
return response.json();
})
.then((data) => {
data.products.forEach(element => {
console.log(element.title);
});
})
.catch(error => {
console.error('error');
});
}

getDataFromServer('https://dummyjson.com/products');
*/

/* Задание 4
Разработайте простой веб-интерфейс для отображения списка пользователей, получаемого с сервера. 
Вам необходимо отобразить имена пользователей и их email-адреса.
Используйте функцию fetch для отправки GET-запроса к https://jsonplaceholder.typicode.com/users . 
Этот запрос вернет JSON-массив объектов пользователей.
В обработчике .then() преобразуйте полученный ответ в JSON.
После успешного получения и преобразования ответа в JSON, отобразите на странице список 
пользователей. Для каждого пользователя покажите его имя и email. Для отображения можно 
использовать любой HTML-элемент, например, ul для списка и li для элементов списка.
Добавьте базовую обработку ошибок, чтобы в случае неудачного запроса на странице отображалось 
сообщение об ошибке.
*/

//см. 4.html

